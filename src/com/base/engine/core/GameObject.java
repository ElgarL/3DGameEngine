/*
 * Copyright (C) 2014 Benny Bobaganoosh
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.base.engine.core;

import java.util.ArrayList;
import java.util.UUID;

import com.base.engine.components.GameComponent;
import com.base.engine.rendering.RenderingEngine;
import com.base.engine.rendering.Shader;

public class GameObject {
	private ArrayList<GameObject> children;
	private ArrayList<GameComponent> components;
	private Transform transform;
	private CoreEngine engine;
	private final String objectId;

	/**
	 * Create a {@link GameObject} with an object id (name) generated by
	 * {@link UUID}.randomUUID().toString();
	 *
	 */
	public GameObject() {
		this(UUID.randomUUID().toString());
	}

	/**
	 * Create a {@link GameObject} and supply an object id.
	 * 
	 * @param objectId
	 *            - The name/object id that can be used to identify this object.
	 */
	public GameObject(final String objectId) {
		this.engine = null;
		this.objectId = objectId;
	}

	/**
	 * Check to see if any {@link GameObject} are attached to this
	 * {@link GameObject}
	 * 
	 * @return true if m_children is not null or empty
	 */
	public boolean hasChildren() {
		return children != null && !children.isEmpty();
	}

	/**
	 * Check to see if there are any {@link GameComponent}s attached to this
	 * object
	 * 
	 * @return true if m_children is not null or empty
	 */
	public boolean hasComponents() {
		return components != null && !components.isEmpty();
	}

	/**
	 * Check to see if there is anything attached to this {@link GameObject}
	 * 
	 * @return true if m_children is not null or empty
	 */
	public boolean hasAttached() {
		return hasChildren() || hasComponents();
	}

	public GameObject addChild(final GameObject child) {

		if (children == null) {
			children = new ArrayList<GameObject>();
		}

		children.add(child);
		child.setEngine(engine);
		child.getTransform().setParent(getTransform());

		return this;
	}

	/**
	 * Find a child {@link GameObject} by it's object id.
	 * 
	 * @param objectId
	 *            - The object ID of the targeted game object.
	 * @return <code>null</code> if no object was found
	 */
	public GameObject getChild(final String objectId) {
		if (!hasChildren()) {
			return null;
		}

		for (final GameObject object : children) {
			if (objectId.equals(object.getObjectId())) {
				return object;
			}
		}

		return null;
	}

	public GameObject addComponent(final GameComponent component) {

		if (components == null) {
			components = new ArrayList<GameComponent>();
		}

		components.add(component);
		component.setParent(this);

		return this;
	}

	public void anputAll(final float delta) {
		input(delta);

		if (!hasChildren()) {
			return;
		}

		for (final GameObject child : children) {
			child.anputAll(delta);
		}
	}

	public void updateAll(final float delta) {
		update(delta);

		if (!hasChildren()) {
			return;
		}

		for (final GameObject child : children) {
			child.updateAll(delta);
		}
	}

	public void renderAll(final Shader shader, final RenderingEngine renderingEngine) {
		render(shader, renderingEngine);

		if (!hasChildren()) {
			return;
		}

		for (final GameObject child : children) {
			child.renderAll(shader, renderingEngine);
		}
	}

	public void input(final float delta) {
		if (hasTransform()) {
			transform.update();
		}

		if (!hasComponents()) {
			return;
		}

		for (final GameComponent component : components) {
			component.input(delta);
		}
	}

	public void update(final float delta) {

		if (!hasComponents()) {
			return;
		}

		for (final GameComponent component : components) {
			component.update(delta);
		}
	}

	public void render(final Shader shader, final RenderingEngine renderingEngine) {

		if (!hasComponents()) {
			return;
		}

		for (final GameComponent component : components) {
			component.render(shader, renderingEngine);
		}
	}

	public ArrayList<GameObject> getAllAttached() {
		final ArrayList<GameObject> result = new ArrayList<GameObject>();

		if (!hasChildren()) {
			return result;
		}

		for (final GameObject child : children) {
			result.addAll(child.getAllAttached());
		}

		result.add(this);
		return result;
	}

	public boolean hasTransform() {
		return transform != null;
	}

	public Transform getTransform() {
		if (!hasTransform()) {
			transform = new Transform();
		}
		return transform;
	}

	/**
	 * Get the name of the object
	 * 
	 * @return Either a UUID or a object id set by the constructor
	 */
	public String getObjectId() {
		return objectId;
	}

	public void setEngine(final CoreEngine engine) {
		if (this.engine != engine) {
			this.engine = engine;

			if (hasComponents()) {
				for (final GameComponent component : components) {
					component.addToEngine(engine);
				}
			}

			if (hasChildren()) {
				for (final GameObject child : children) {
					child.setEngine(engine);
				}
			}
		}
	}
}
